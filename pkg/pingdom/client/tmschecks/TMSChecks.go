// Package tmschecks provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package tmschecks

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for CheckGeneralType.
const (
	CheckGeneralTypeRecording CheckGeneralType = "recording"
	CheckGeneralTypeScript    CheckGeneralType = "script"
)

// Defines values for CheckWithoutIDGETType.
const (
	CheckWithoutIDGETTypeRecording CheckWithoutIDGETType = "recording"
	CheckWithoutIDGETTypeScript    CheckWithoutIDGETType = "script"
)

// Defines values for ReportPerformanceReportResolution.
const (
	ReportPerformanceReportResolutionDay  ReportPerformanceReportResolution = "day"
	ReportPerformanceReportResolutionHour ReportPerformanceReportResolution = "hour"
	ReportPerformanceReportResolutionWeek ReportPerformanceReportResolution = "week"
)

// Defines values for StateStatus.
const (
	Down    StateStatus = "down"
	Unknown StateStatus = "unknown"
	Up      StateStatus = "up"
)

// Defines values for GetAllChecksParamsType.
const (
	Recording GetAllChecksParamsType = "recording"
	Script    GetAllChecksParamsType = "script"
)

// Defines values for GetCheckReportStatusAllParamsOrder.
const (
	GetCheckReportStatusAllParamsOrderAsc  GetCheckReportStatusAllParamsOrder = "asc"
	GetCheckReportStatusAllParamsOrderDesc GetCheckReportStatusAllParamsOrder = "desc"
)

// Defines values for GetCheckReportPerformanceParamsOrder.
const (
	GetCheckReportPerformanceParamsOrderAsc  GetCheckReportPerformanceParamsOrder = "asc"
	GetCheckReportPerformanceParamsOrderDesc GetCheckReportPerformanceParamsOrder = "desc"
)

// Defines values for GetCheckReportPerformanceParamsResolution.
const (
	GetCheckReportPerformanceParamsResolutionDay  GetCheckReportPerformanceParamsResolution = "day"
	GetCheckReportPerformanceParamsResolutionHour GetCheckReportPerformanceParamsResolution = "hour"
	GetCheckReportPerformanceParamsResolutionWeek GetCheckReportPerformanceParamsResolution = "week"
)

// Defines values for GetCheckReportStatusParamsOrder.
const (
	Asc  GetCheckReportStatusParamsOrder = "asc"
	Desc GetCheckReportStatusParamsOrder = "desc"
)

// AverageResponse Average response times in milliseconds
type AverageResponse = int64

// CheckGeneral defines model for CheckGeneral.
type CheckGeneral struct {
	// Active Check status: active or inactive
	Active *bool `json:"active,omitempty"`

	// CreatedAt Timestamp when the check was created
	CreatedAt *int64 `json:"created_at,omitempty"`

	// Id Id of the check
	CheckID *int64 `json:"id,omitempty"`

	// Interval TMS test intervals in minutes. Allowed intervals: 5,10,20,60,720,1440. The interval you're allowed to set may vary depending on your current plan.
	Interval *int64 `json:"interval,omitempty"`

	// LastDowntimeEnd Timestamp when the last downtime ended. This field is optional
	LastDowntimeEnd *int64 `json:"last_downtime_end,omitempty"`

	// LastDowntimeStart Timestamp when the last downtime started. This field is optional
	LastDowntimeStart *int64 `json:"last_downtime_start,omitempty"`

	// ModifiedAt Timestamp when the check was modified
	ModifiedAt *int64 `json:"modified_at,omitempty"`

	// Name Name of the check
	Name *string `json:"name,omitempty"`

	// Region Name of the region where the check is executed. Supported regions: us-east, us-west, eu, au
	Region *string `json:"region,omitempty"`

	// Status Whether the check is passing or failing at the moment (successful, failing, unknown)
	Status *string `json:"status,omitempty"`

	// Tags List of tags for a check. The tag name may contain the characters 'A-Z', 'a-z', '0-9', '_' and '-'. The maximum length of a tag is 64 characters.
	Tags *[]string `json:"tags,omitempty"`

	// Type Type of transaction check: "script" for regular TMS checks and "recording" for checks made using the Transaction Recorder
	Type *CheckGeneralType `json:"type,omitempty"`
}

// CheckGeneralType Type of transaction check: "script" for regular TMS checks and "recording" for checks made using the Transaction Recorder
type CheckGeneralType string

// CheckSimple defines model for CheckSimple.
type CheckSimple struct {
	// Id Id of the check
	CheckID *int64 `json:"id,omitempty"`

	// Name Name of the check
	Name *string `json:"name,omitempty"`
}

// CustomCheckStatus defines model for CheckStatus.
type CustomCheckStatus struct {
	// CheckId ID of the check
	CheckId *PropertyCheckID `json:"check_id,omitempty"`

	// Name Name of the check
	Name *PropertyCheckName `json:"name,omitempty"`

	// States Intervals when the check had a specific status (`up`/`down`).
	States *[]State `json:"states,omitempty"`
}

// CheckWithoutID CheckWithoutID is a struct describing a TMS check data common for creating a check
type CheckWithoutID struct {
	// Active Check status: active or inactive
	Active *bool `json:"active,omitempty"`

	// ContactIds Contacts to alert
	ContactIDs *[]int64 `json:"contact_ids,omitempty"`

	// CustomMessage Custom message that is part of the email and webhook alerts
	CustomMessage *string `json:"custom_message,omitempty"`

	// IntegrationIds Integration identifiers.
	IntegrationIDs *[]int64 `json:"integration_ids,omitempty"`

	// Interval TMS test intervals in minutes. Allowed intervals: 5,10,20,60,720,1440. The interval you're allowed to set may vary depending on your current plan.
	Interval *int64 `json:"interval,omitempty"`

	// Metadata Recording related metadata. Used for recordings only. Modify with caution!
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name Name of the check
	Name string `json:"name"`

	// Region Name of the region where the check is executed. Supported regions: us-east, us-west, eu, au
	Region *string `json:"region,omitempty"`

	// SendNotificationWhenDown Send notification when down X times
	NotifyAfter *int64 `json:"send_notification_when_down,omitempty"`

	// SeverityLevel Check importance- how important are the alerts when the check fails. Allowed values: low, high
	SeverityLevel *string `json:"severity_level,omitempty"`

	// Steps steps to be executed as part of the check
	Steps []Step `json:"steps"`

	// Tags List of tags for a check. The tag name may contain the characters 'A-Z', 'a-z', '0-9', '_' and '-'. The maximum length of a tag is 64 characters.
	Tags *[]string `json:"tags,omitempty"`

	// TeamIds Teams to alert
	TeamIDs *[]int64 `json:"team_ids,omitempty"`
}

// CheckWithoutIDGET CheckWithoutIDGET is a struct describing a TMS check data common for displaying a check
type CheckWithoutIDGET struct {
	// Active Check status - active or inactive
	Active *bool `json:"active,omitempty"`

	// ContactIds Contacts to alert
	ContactIDs *[]int64 `json:"contact_ids,omitempty"`

	// CreatedAt Timestamp when the check was created
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CustomMessage Custom message that is part of the email and webhook alerts
	CustomMessage *string `json:"custom_message,omitempty"`

	// IntegrationIds Integration identifiers.
	IntegrationIDs *[]int64 `json:"integration_ids,omitempty"`

	// Interval TMS test intervals in minutes. Allowed intervals: 5,10,20,60,720,1440. The interval you're allowed to set may vary depending on your current plan.
	Interval *int64 `json:"interval,omitempty"`

	// LastDowntimeEnd Timestamp when the last downtime ended. This field is optional
	LastDowntimeEnd *int64 `json:"last_downtime_end,omitempty"`

	// LastDowntimeStart Timestamp when the last downtime started. This field is optional
	LastDowntimeStart *int64 `json:"last_downtime_start,omitempty"`

	// Metadata Recording related metadata. Used for recordings only. Modify with caution!
	Metadata *MetadataGET `json:"metadata,omitempty"`

	// ModifiedAt Timestamp when the check was modified
	ModifiedAt *int64 `json:"modified_at,omitempty"`

	// Name Name of the check
	Name *string `json:"name,omitempty"`

	// Region Name of the region where the check is executed. Supported regions: us-east, us-west, eu, au
	Region *string `json:"region,omitempty"`

	// SendNotificationWhenDown Send notification when down X times
	NotifyAfter *int64 `json:"send_notification_when_down,omitempty"`

	// SeverityLevel Check importance- how important are the alerts when the check fails. Allowed values: low, high
	SeverityLevel *string `json:"severity_level,omitempty"`

	// Status Whether the check is passing or failing at the moment (successful, failing, unknown)
	Status *string `json:"status,omitempty"`

	// Steps steps to be executed as part of the check
	Steps *[]Step `json:"steps,omitempty"`

	// Tags List of tags for a check. The tag name may contain the characters 'A-Z', 'a-z', '0-9', '_' and '-'. The maximum length of a tag is 64 characters.
	Tags *[]string `json:"tags,omitempty"`

	// TeamIds Teams to alert
	TeamIDs *[]int64 `json:"team_ids,omitempty"`

	// Type Type of transaction check: "script" for regular TMS checks and "recording" for checks made using the Transaction Recorder
	Type *CheckWithoutIDGETType `json:"type,omitempty"`
}

// CheckWithoutIDGETType Type of transaction check: "script" for regular TMS checks and "recording" for checks made using the Transaction Recorder
type CheckWithoutIDGETType string

// CheckWithoutIDPUT CheckWithoutIDPUT is a struct describing a TMS check data common for updating a check
type CheckWithoutIDPUT struct {
	// Active Check status: active or inactive
	Active *bool `json:"active,omitempty"`

	// ContactIds Contacts to alert
	ContactIDs *[]int64 `json:"contact_ids,omitempty"`

	// CustomMessage Custom message that is part of the email and webhook alerts
	CustomMessage *string `json:"custom_message,omitempty"`

	// IntegrationIds Integration identifiers as a list of integers.
	IntegrationIds *[]int `json:"integration_ids,omitempty"`

	// Interval TMS test intervals in minutes. Allowed intervals: 5,10,20,60,720,1440. The interval you're allowed to set may vary depending on your current plan.
	Interval *int64 `json:"interval,omitempty"`

	// Metadata Recording related metadata. Used for recordings only. Modify with caution!
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name Name of the check
	Name *string `json:"name,omitempty"`

	// Region Name of the region where the check is executed. Supported regions: us-east, us-west, eu, au
	Region *string `json:"region,omitempty"`

	// SendNotificationWhenDown Send notification when down X times
	NotifyAfter *int64 `json:"send_notification_when_down,omitempty"`

	// SeverityLevel Check importance- how important are the alerts when the check fails. Allowed values: low, high
	SeverityLevel *string `json:"severity_level,omitempty"`

	// Steps steps to be executed as part of the check
	Steps *[]Step `json:"steps,omitempty"`

	// Tags List of tags for a check. The tag name may contain the characters 'A-Z', 'a-z', '0-9', '_' and '-'. The maximum length of a tag is 64 characters.
	Tags *[]string `json:"tags,omitempty"`

	// TeamIds Teams to alert
	TeamIDs *[]int64 `json:"team_ids,omitempty"`
}

// ChecksAll defines model for ChecksAll.
type ChecksAll struct {
	Check  *[]CheckGeneral `json:"checks,omitempty"`
	Limit  *uint64         `json:"limit,omitempty"`
	Offset *uint64         `json:"offset,omitempty"`
}

// Downtime Amount of time when the check was down within given interval (only with the `include_uptime` flag)
type Downtime = int64

// HttpAuthentications defines model for HttpAuthentications.
type HttpAuthentications struct {
	// Credentials Basic Authentication credentials to use on host
	Credentials *struct {
		// Password Basic Authentication password
		Password *string `json:"password,omitempty"`

		// UserName Basic Authentication Username
		UserName *string `json:"userName,omitempty"`
	} `json:"credentials,omitempty"`
	Host *string `json:"host,omitempty"`
}

// Metadata Recording related metadata. Used for recordings only. Modify with caution!
type Metadata struct {
	// Authentications Allowed values are either an empty JSON object (no authentication) or Basic Authentication
	Authentications struct {
		// HttpAuthentications HTTP (browser-level) authentications. Currently, only Basic Authentication is supported
		HttpAuthentications *[]HttpAuthentications `json:"httpAuthentications,omitempty"`
	} `json:"authentications"`

	// DisableWebSecurity Setting this field to false will disable the same-origin policy during check execution
	DisableWebSecurity bool `json:"disableWebSecurity"`

	// Height Height of the browser window
	Height int `json:"height"`

	// Width Width of the browser window
	Width int `json:"width"`
}

// MetadataGET Recording related metadata. Used for recordings only. Modify with caution!
type MetadataGET struct {
	// Authentications Allowed values are either an empty JSON object (no authentication) or Basic Authentication
	Authentications *struct {
		// HttpAuthentications HTTP (browser-level) authentications. Currently, only Basic Authentication is supported
		HttpAuthentications *[]HttpAuthentications `json:"httpAuthentications,omitempty"`
	} `json:"authentications,omitempty"`

	// DisableWebSecurity Setting this field to false will disable the same-origin policy during check execution
	DisableWebSecurity *bool `json:"disableWebSecurity,omitempty"`

	// Height Height of the browser window
	Height *int `json:"height,omitempty"`

	// Width Width of the browser window
	Width *int `json:"width,omitempty"`
}

// PropertyCheckID ID of the check
type PropertyCheckID = int64

// PropertyCheckName Name of the check
type PropertyCheckName = string

// PropertyFrom Interval start. The format is `RFC 3339`
type PropertyFrom = time.Time

// ReportPerformance defines model for ReportPerformance.
type ReportPerformance struct {
	Report *struct {
		// CheckId ID of the check
		CheckId *PropertyCheckID `json:"check_id,omitempty"`

		// Intervals Intervals for which the measurements were performed.
		Intervals *[]struct {
			// AverageResponse Average response times in milliseconds
			AverageResponse *AverageResponse `json:"average_response,omitempty"`

			// Downtime Amount of time when the check was down within given interval (only with the `include_uptime` flag)
			Downtime *Downtime `json:"downtime,omitempty"`

			// From Interval start. The format is `RFC 3339`
			From  *PropertyFrom `json:"from,omitempty"`
			Steps *[]struct {
				// AverageResponse Average response times in milliseconds
				AverageResponse *AverageResponse `json:"average_response,omitempty"`

				// Step Step is a struct describing a single step of a TMS check
				Step *Step `json:"step,omitempty"`
			} `json:"steps,omitempty"`

			// Unmonitored Amount of time when there is no specific data about check status (up/down) within given interval (only with the `include_uptime` flag)
			Unmonitored *Unmonitored `json:"unmonitored,omitempty"`

			// Uptime Amount of time when the check was up within given interval (only with the `include_uptime` flag)
			Uptime *Uptime `json:"uptime,omitempty"`
		} `json:"intervals,omitempty"`

		// Name Name of the check
		Name *PropertyCheckName `json:"name,omitempty"`

		// Resolution Size of a time bucket for which the results are calculated
		Resolution *ReportPerformanceReportResolution `json:"resolution,omitempty"`
	} `json:"report,omitempty"`
}

// ReportPerformanceReportResolution Size of a time bucket for which the results are calculated
type ReportPerformanceReportResolution string

// ReportStatusAll defines model for ReportStatusAll.
type ReportStatusAll struct {
	Report *[]CustomCheckStatus `json:"report,omitempty"`
}

// ReportStatusSingle defines model for ReportStatusSingle.
type ReportStatusSingle struct {
	CustomCheckStatus *CustomCheckStatus `json:"report,omitempty"`
}

// State defines model for State.
type State struct {
	// ErrorInStep Number of step in which an error has occured (only if `status` is `down`)
	ErrorInStep *int `json:"error_in_step,omitempty"`

	// From Interval start. The format is `RFC 3339`
	From *PropertyFrom `json:"from,omitempty"`

	// Message Error message for the step that is failing (only if `status` is `down`)
	Message *string `json:"message,omitempty"`

	// Status Interval status
	Status *StateStatus `json:"status,omitempty"`

	// To Interval end. The format is `RFC 3339`
	To *time.Time `json:"to,omitempty"`
}

// StateStatus Interval status
type StateStatus string

// Step Step is a struct describing a single step of a TMS check
type Step struct {
	// Args Parameters for the operation
	// The actual parameters required depend on the chosen operation
	Parameters *struct {
		Checkbox *string `json:"checkbox,omitempty"`
		Element  *string `json:"element,omitempty"`
		Form     *string `json:"form,omitempty"`
		Input    *string `json:"input,omitempty"`
		Option   *string `json:"option,omitempty"`
		Password *string `json:"password,omitempty"`
		Radio    *string `json:"radio,omitempty"`
		Seconds  *string `json:"seconds,omitempty"`
		Select   *string `json:"select,omitempty"`
		URL      *string `json:"url,omitempty"`
		Username *string `json:"username,omitempty"`
		Value    *string `json:"value,omitempty"`
	} `json:"args,omitempty"`

	// Fn Operation to be done
	Function *string `json:"fn,omitempty"`
}

// Unmonitored Amount of time when there is no specific data about check status (up/down) within given interval (only with the `include_uptime` flag)
type Unmonitored = int64

// Uptime Amount of time when the check was up within given interval (only with the `include_uptime` flag)
type Uptime = int64

// CheckAddedResponse defines model for checkAddedResponse.
type CheckAddedResponse = CheckSimple

// CheckDeletedResponse defines model for checkDeletedResponse.
type CheckDeletedResponse struct {
	Message *string `json:"message,omitempty"`
}

// CheckDetailed CheckWithoutIDGET is a struct describing a TMS check data common for displaying a check
type CheckDetailed = CheckWithoutIDGET

// CheckModifiedResponse CheckWithoutIDGET is a struct describing a TMS check data common for displaying a check
type CheckModifiedResponse = CheckWithoutIDGET

// GetAllChecksParams defines parameters for GetAllChecks.
type GetAllChecksParams struct {
	// ExtendedTags Specifies whether to return an extended tags representation in the response (with type and count).
	ExtendedTags *bool `form:"extended_tags,omitempty" json:"extended_tags,omitempty"`

	// Tags Tag list separated by commas. As an example "nginx,apache" would filter out all responses except those tagged nginx or apache
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Type Filter to return only checks of a given type (a TMS `script` or a WPM `recording`). If not provided, all checks are returned.
	Type *GetAllChecksParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Limit Limit of returned checks
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of returned checks
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetAllChecksParamsType defines parameters for GetAllChecks.
type GetAllChecksParamsType string

// GetCheckReportStatusAllParams defines parameters for GetCheckReportStatusAll.
type GetCheckReportStatusAllParams struct {
	// From Start time of period. The format is `RFC 3339` (properly URL-encoded!). The default value is one week earlier than `to`
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End time of period. The format is `RFC 3339` (properly URL-encoded!). The default value is the current time
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Order Sorting order of outages. Ascending or descending
	Order *GetCheckReportStatusAllParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit of returned checks
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of returned checks
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// OmitEmpty Omits checks without any results within specified time
	OmitEmpty *bool `form:"omit_empty,omitempty" json:"omit_empty,omitempty"`
}

// GetCheckReportStatusAllParamsOrder defines parameters for GetCheckReportStatusAll.
type GetCheckReportStatusAllParamsOrder string

// GetCheckReportPerformanceParams defines parameters for GetCheckReportPerformance.
type GetCheckReportPerformanceParams struct {
	// From Start time of period. The format is `RFC 3339` (properly URL-encoded!). The default value is 10 times the resolution (10 hours, 10 day, 10 weeks) earlier than `to`. The value is extended to the nearest hour, day or week, depending on the 'resolution' parameter and configured time zone of the account.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End time of period. The format is `RFC 3339` (properly URL-encoded!). The default value is the current time. The value is extended to the nearest hour, day or week, depending on the 'resolution' parameter and configured time zone of the account.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Order Sorting order of outages. Ascending or descending
	Order *GetCheckReportPerformanceParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Resolution Size of an interval for which the results are calculated. For the `hour` resolution, the max allowed period is one week and 1 day. For the `day` resolution, the max allowed period is 6 months and 1 day.
	Resolution *GetCheckReportPerformanceParamsResolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// IncludeUptime Include uptime information. Adds field downtime, uptime, and unmonitored to the interval array objects.
	IncludeUptime *bool `form:"include_uptime,omitempty" json:"include_uptime,omitempty"`
}

// GetCheckReportPerformanceParamsOrder defines parameters for GetCheckReportPerformance.
type GetCheckReportPerformanceParamsOrder string

// GetCheckReportPerformanceParamsResolution defines parameters for GetCheckReportPerformance.
type GetCheckReportPerformanceParamsResolution string

// GetCheckReportStatusParams defines parameters for GetCheckReportStatus.
type GetCheckReportStatusParams struct {
	// From Start time of period. The format is `RFC 3339` (properly URL-encoded!). The default value is one week earlier than `to`
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End time of period. The format is `RFC 3339` (properly URL-encoded!). The default value is the current time
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Order Sorting order of outages. Ascending or descending
	Order *GetCheckReportStatusParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// GetCheckReportStatusParamsOrder defines parameters for GetCheckReportStatus.
type GetCheckReportStatusParamsOrder string

// GetCheckParams defines parameters for GetCheck.
type GetCheckParams struct {
	// ExtendedTags Specifies whether to return an extended tags representation in the response (with type and count).
	ExtendedTags *bool `form:"extended_tags,omitempty" json:"extended_tags,omitempty"`
}

// AddCheckJSONRequestBody defines body for AddCheck for application/json ContentType.
type AddCheckJSONRequestBody = CheckWithoutID

// ModifyCheckJSONRequestBody defines body for ModifyCheck for application/json ContentType.
type ModifyCheckJSONRequestBody = CheckWithoutIDPUT

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllChecks request
	GetAllChecks(ctx context.Context, params *GetAllChecksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCheckWithBody request with any body
	AddCheckWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCheck(ctx context.Context, body AddCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCheckReportStatusAll request
	GetCheckReportStatusAll(ctx context.Context, params *GetCheckReportStatusAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCheckReportPerformance request
	GetCheckReportPerformance(ctx context.Context, checkId int64, params *GetCheckReportPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCheckReportStatus request
	GetCheckReportStatus(ctx context.Context, checkId int64, params *GetCheckReportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCheck request
	DeleteCheck(ctx context.Context, checkID int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCheck request
	GetCheck(ctx context.Context, checkID int64, params *GetCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyCheckWithBody request with any body
	ModifyCheckWithBody(ctx context.Context, checkID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyCheck(ctx context.Context, checkID int64, body ModifyCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllChecks(ctx context.Context, params *GetAllChecksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllChecksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCheckWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCheckRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCheck(ctx context.Context, body AddCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCheckRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCheckReportStatusAll(ctx context.Context, params *GetCheckReportStatusAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCheckReportStatusAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCheckReportPerformance(ctx context.Context, checkId int64, params *GetCheckReportPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCheckReportPerformanceRequest(c.Server, checkId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCheckReportStatus(ctx context.Context, checkId int64, params *GetCheckReportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCheckReportStatusRequest(c.Server, checkId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCheck(ctx context.Context, checkID int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCheckRequest(c.Server, checkID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCheck(ctx context.Context, checkID int64, params *GetCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCheckRequest(c.Server, checkID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyCheckWithBody(ctx context.Context, checkID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyCheckRequestWithBody(c.Server, checkID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyCheck(ctx context.Context, checkID int64, body ModifyCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyCheckRequest(c.Server, checkID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllChecksRequest generates requests for GetAllChecks
func NewGetAllChecksRequest(server string, params *GetAllChecksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tms/check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExtendedTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extended_tags", runtime.ParamLocationQuery, *params.ExtendedTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddCheckRequest calls the generic AddCheck builder with application/json body
func NewAddCheckRequest(server string, body AddCheckJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCheckRequestWithBody(server, "application/json", bodyReader)
}

// NewAddCheckRequestWithBody generates requests for AddCheck with any type of body
func NewAddCheckRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tms/check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCheckReportStatusAllRequest generates requests for GetCheckReportStatusAll
func NewGetCheckReportStatusAllRequest(server string, params *GetCheckReportStatusAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tms/check/report/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OmitEmpty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "omit_empty", runtime.ParamLocationQuery, *params.OmitEmpty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCheckReportPerformanceRequest generates requests for GetCheckReportPerformance
func NewGetCheckReportPerformanceRequest(server string, checkId int64, params *GetCheckReportPerformanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "check_id", runtime.ParamLocationPath, checkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tms/check/%s/report/performance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUptime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_uptime", runtime.ParamLocationQuery, *params.IncludeUptime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCheckReportStatusRequest generates requests for GetCheckReportStatus
func NewGetCheckReportStatusRequest(server string, checkId int64, params *GetCheckReportStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "check_id", runtime.ParamLocationPath, checkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tms/check/%s/report/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCheckRequest generates requests for DeleteCheck
func NewDeleteCheckRequest(server string, checkID int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cid", runtime.ParamLocationPath, checkID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tms/check/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCheckRequest generates requests for GetCheck
func NewGetCheckRequest(server string, checkID int64, params *GetCheckParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cid", runtime.ParamLocationPath, checkID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tms/check/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExtendedTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extended_tags", runtime.ParamLocationQuery, *params.ExtendedTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyCheckRequest calls the generic ModifyCheck builder with application/json body
func NewModifyCheckRequest(server string, checkID int64, body ModifyCheckJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyCheckRequestWithBody(server, checkID, "application/json", bodyReader)
}

// NewModifyCheckRequestWithBody generates requests for ModifyCheck with any type of body
func NewModifyCheckRequestWithBody(server string, checkID int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cid", runtime.ParamLocationPath, checkID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tms/check/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllChecksWithResponse request
	GetAllChecksWithResponse(ctx context.Context, params *GetAllChecksParams, reqEditors ...RequestEditorFn) (*GetAllChecksResponse, error)

	// AddCheckWithBodyWithResponse request with any body
	AddCheckWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCheckResponse, error)

	AddCheckWithResponse(ctx context.Context, body AddCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCheckResponse, error)

	// GetCheckReportStatusAllWithResponse request
	GetCheckReportStatusAllWithResponse(ctx context.Context, params *GetCheckReportStatusAllParams, reqEditors ...RequestEditorFn) (*GetCheckReportStatusAllResponse, error)

	// GetCheckReportPerformanceWithResponse request
	GetCheckReportPerformanceWithResponse(ctx context.Context, checkId int64, params *GetCheckReportPerformanceParams, reqEditors ...RequestEditorFn) (*GetCheckReportPerformanceResponse, error)

	// GetCheckReportStatusWithResponse request
	GetCheckReportStatusWithResponse(ctx context.Context, checkId int64, params *GetCheckReportStatusParams, reqEditors ...RequestEditorFn) (*GetCheckReportStatusResponse, error)

	// DeleteCheckWithResponse request
	DeleteCheckWithResponse(ctx context.Context, checkID int64, reqEditors ...RequestEditorFn) (*DeleteCheckResponse, error)

	// GetCheckWithResponse request
	GetCheckWithResponse(ctx context.Context, checkID int64, params *GetCheckParams, reqEditors ...RequestEditorFn) (*GetCheckResponse, error)

	// ModifyCheckWithBodyWithResponse request with any body
	ModifyCheckWithBodyWithResponse(ctx context.Context, checkID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyCheckResponse, error)

	ModifyCheckWithResponse(ctx context.Context, checkID int64, body ModifyCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyCheckResponse, error)
}

type GetAllChecksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChecksAll
}

// Status returns HTTPResponse.Status
func (r GetAllChecksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllChecksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckAddedResponse
}

// Status returns HTTPResponse.Status
func (r AddCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCheckReportStatusAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportStatusAll
}

// Status returns HTTPResponse.Status
func (r GetCheckReportStatusAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCheckReportStatusAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCheckReportPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportPerformance
}

// Status returns HTTPResponse.Status
func (r GetCheckReportPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCheckReportPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCheckReportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportStatusSingle
}

// Status returns HTTPResponse.Status
func (r GetCheckReportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCheckReportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckDeletedResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckDetailed
}

// Status returns HTTPResponse.Status
func (r GetCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckModifiedResponse
}

// Status returns HTTPResponse.Status
func (r ModifyCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllChecksWithResponse request returning *GetAllChecksResponse
func (c *ClientWithResponses) GetAllChecksWithResponse(ctx context.Context, params *GetAllChecksParams, reqEditors ...RequestEditorFn) (*GetAllChecksResponse, error) {
	rsp, err := c.GetAllChecks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllChecksResponse(rsp)
}

// AddCheckWithBodyWithResponse request with arbitrary body returning *AddCheckResponse
func (c *ClientWithResponses) AddCheckWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCheckResponse, error) {
	rsp, err := c.AddCheckWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCheckResponse(rsp)
}

func (c *ClientWithResponses) AddCheckWithResponse(ctx context.Context, body AddCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCheckResponse, error) {
	rsp, err := c.AddCheck(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCheckResponse(rsp)
}

// GetCheckReportStatusAllWithResponse request returning *GetCheckReportStatusAllResponse
func (c *ClientWithResponses) GetCheckReportStatusAllWithResponse(ctx context.Context, params *GetCheckReportStatusAllParams, reqEditors ...RequestEditorFn) (*GetCheckReportStatusAllResponse, error) {
	rsp, err := c.GetCheckReportStatusAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCheckReportStatusAllResponse(rsp)
}

// GetCheckReportPerformanceWithResponse request returning *GetCheckReportPerformanceResponse
func (c *ClientWithResponses) GetCheckReportPerformanceWithResponse(ctx context.Context, checkId int64, params *GetCheckReportPerformanceParams, reqEditors ...RequestEditorFn) (*GetCheckReportPerformanceResponse, error) {
	rsp, err := c.GetCheckReportPerformance(ctx, checkId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCheckReportPerformanceResponse(rsp)
}

// GetCheckReportStatusWithResponse request returning *GetCheckReportStatusResponse
func (c *ClientWithResponses) GetCheckReportStatusWithResponse(ctx context.Context, checkId int64, params *GetCheckReportStatusParams, reqEditors ...RequestEditorFn) (*GetCheckReportStatusResponse, error) {
	rsp, err := c.GetCheckReportStatus(ctx, checkId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCheckReportStatusResponse(rsp)
}

// DeleteCheckWithResponse request returning *DeleteCheckResponse
func (c *ClientWithResponses) DeleteCheckWithResponse(ctx context.Context, checkID int64, reqEditors ...RequestEditorFn) (*DeleteCheckResponse, error) {
	rsp, err := c.DeleteCheck(ctx, checkID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCheckResponse(rsp)
}

// GetCheckWithResponse request returning *GetCheckResponse
func (c *ClientWithResponses) GetCheckWithResponse(ctx context.Context, checkID int64, params *GetCheckParams, reqEditors ...RequestEditorFn) (*GetCheckResponse, error) {
	rsp, err := c.GetCheck(ctx, checkID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCheckResponse(rsp)
}

// ModifyCheckWithBodyWithResponse request with arbitrary body returning *ModifyCheckResponse
func (c *ClientWithResponses) ModifyCheckWithBodyWithResponse(ctx context.Context, checkID int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyCheckResponse, error) {
	rsp, err := c.ModifyCheckWithBody(ctx, checkID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyCheckResponse(rsp)
}

func (c *ClientWithResponses) ModifyCheckWithResponse(ctx context.Context, checkID int64, body ModifyCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyCheckResponse, error) {
	rsp, err := c.ModifyCheck(ctx, checkID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyCheckResponse(rsp)
}

// ParseGetAllChecksResponse parses an HTTP response from a GetAllChecksWithResponse call
func ParseGetAllChecksResponse(rsp *http.Response) (*GetAllChecksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllChecksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChecksAll
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddCheckResponse parses an HTTP response from a AddCheckWithResponse call
func ParseAddCheckResponse(rsp *http.Response) (*AddCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckAddedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCheckReportStatusAllResponse parses an HTTP response from a GetCheckReportStatusAllWithResponse call
func ParseGetCheckReportStatusAllResponse(rsp *http.Response) (*GetCheckReportStatusAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCheckReportStatusAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportStatusAll
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCheckReportPerformanceResponse parses an HTTP response from a GetCheckReportPerformanceWithResponse call
func ParseGetCheckReportPerformanceResponse(rsp *http.Response) (*GetCheckReportPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCheckReportPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportPerformance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCheckReportStatusResponse parses an HTTP response from a GetCheckReportStatusWithResponse call
func ParseGetCheckReportStatusResponse(rsp *http.Response) (*GetCheckReportStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCheckReportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportStatusSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCheckResponse parses an HTTP response from a DeleteCheckWithResponse call
func ParseDeleteCheckResponse(rsp *http.Response) (*DeleteCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckDeletedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCheckResponse parses an HTTP response from a GetCheckWithResponse call
func ParseGetCheckResponse(rsp *http.Response) (*GetCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckDetailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyCheckResponse parses an HTTP response from a ModifyCheckWithResponse call
func ParseModifyCheckResponse(rsp *http.Response) (*ModifyCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckModifiedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
